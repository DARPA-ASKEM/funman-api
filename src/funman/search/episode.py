from pydantic import BaseModel

from funman.funman import FUNMANConfig
from funman.scenario.scenario import AnalysisScenario
from funman.search.search import SearchStatistics


class SearchEpisode(BaseModel):
    class Config:
        arbitrary_types_allowed = True
        underscore_attrs_are_private = True

    problem: AnalysisScenario
    config: FUNMANConfig
    statistics: SearchStatistics = None
    _model: pysmt.solvers.solver.Model = None

    def num_parameters(self):
        return len(self.problem.parameters)


class BoxSearchEpisode(SearchEpisode):
    """
    A BoxSearchEpisode stores the data required to organize a BoxSearch, including intermediate data and results. It takes as input:

    * config: a SearchConfig object that defines the configuration

    * problem: a ParameterSynthesisScenario to solve

    * manager: a SyncManager for coordinating multiple search processes that is used to declare several shared data

    A BoxSearchEpisode mainly tracks the true, false, and unknown boxes generated by the BoxSearch, along with statistics on the search.
    """

    class Config:
        underscore_attrs_are_private = True
        arbitrary_types_allowed = True

    # problem: ParameterSynthesisScenario
    statistics: SearchStatistics = None
    _true_boxes: List[Box] = []
    _false_boxes: List[Box] = []
    _true_points: Set[Point] = set({})
    _false_points: Set[Point] = set({})
    _unknown_boxes: QueueSP
    _iteration: int = 0
    _formula_stack: List[FNode] = []

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._unknown_boxes = QueueSP()
        self.statistics = SearchStatistics()

    # def __init__(
    #     self,
    #     config: SearchConfig,
    #     problem: "ParameterSynthesisScenario",
    #     manager: Optional[SyncManager] = None,
    # ) -> None:
    #     super(BoxSearchEpisode, self).__init__(config, problem)
    #     self.statistics = SearchStatistics.from_manager(manager)
    #     self._unknown_boxes = manager.Queue() if manager else SQueue()
    #     self._true_boxes: List[Box] = []
    #     self.false_boxes: List[Box] = []
    #     self._true_points: Set[Point] = set({})
    #     self._false_points: Set[Point] = set({})

    #     self.iteration = manager.Value("i", 0) if manager else 0

    def _initialize_boxes(self, expander_count):
        initial_box = self._initial_box()
        # if not self.add_unknown(initial_box):
        #     l.exception(
        #         f"Did not add an initial box (of width {initial_box.width()}), try reducing config.tolerance, currently {self.config.tolerance}"
        #     )
        initial_boxes = QueueSP()
        initial_boxes.put(self._initial_box())
        num_boxes = 1
        while num_boxes < expander_count:
            b1, b2 = initial_boxes.get().split()
            initial_boxes.put(b1)
            initial_boxes.put(b2)
            num_boxes += 1
        for i in range(num_boxes):
            b = initial_boxes.get()
            if not self._add_unknown(b):
                l.exception(
                    f"Did not add an initial box (of width {b.width()}), try reducing config.tolerance, currently {self.config.tolerance}"
                )
            l.debug(f"Initial box: {b}")

    def _initial_box(self) -> Box:
        return Box(
            bounds={
                p.name: Interval(lb=p.lb, ub=p.ub)
                for p in self.problem.parameters
            }
        )

    def _on_start(self):
        if self.config.number_of_processes > 1:
            self.statistics._last_time.value = str(datetime.now())
        else:
            self.statistics._last_time = str(datetime.now())

    # def close(self):
    #     if self.multiprocessing:
    #         self.unknown_boxes.close()
    #         self.statistics.close()
    #         self.boxes_to_plot.close()

    def _on_iteration(self):
        if self.config.number_of_processes > 1:
            self._iteration.value = self._iteration.value + 1
        else:
            self._iteration = self._iteration + 1

    def _add_unknown_box(self, box: Box) -> bool:
        if box.width() > self.config.tolerance:
            box.label = LABEL_UNKNOWN
            self._unknown_boxes.put(box)
            if self.config.number_of_processes > 1:
                self.statistics._num_unknown.value += 1
            else:
                self.statistics._num_unknown += 1
            return True
        else:
            box.label = LABEL_DROPPED
        return False

    def _add_unknown(self, box: Union[Box, List[Box]]):
        did_add = False
        if isinstance(box, list):
            for b in box:
                did_add |= self._add_unknown_box(b)
        else:
            did_add = self._add_unknown_box(box)
        return did_add

    def _add_false(self, box: Box):
        box.label = LABEL_FALSE
        self._false_boxes.append(box)
        # with self.statistics.num_false.get_lock():
        #     self.statistics.num_false.value += 1
        # self.statistics.iteration_operation.put("f")

    def _add_false_point(self, point: Point):
        if point in self._true_points:
            l.error(
                f"Point: {point} is marked false, but already marked true."
            )
        point.label = LABEL_FALSE
        self._false_points.add(point)

    def _add_true(self, box: Box):
        box.label = LABEL_TRUE
        self._true_boxes.append(box)
        # with self.statistics.num_true.get_lock():
        #     self.statistics.num_true.value += 1
        # self.statistics.iteration_operation.put("t")

    def _add_true_point(self, point: Point):
        if point in self._false_points:
            l.error(
                f"Point: {point} is marked true, but already marked false."
            )
        point.label = LABEL_TRUE
        self._true_points.add(point)

    def _get_unknown(self):
        box = self._unknown_boxes.get(timeout=self.config.queue_timeout)
        if self.config.number_of_processes > 1:
            self.statistics._num_unknown.value = (
                self.statistics._num_unknown.value - 1
            )
            self.statistics._current_residual.value = box.width()
        else:
            self.statistics._num_unknown += 1
            self.statistics._current_residual = box.width()
        self.statistics._residuals.put(box.width())
        this_time = datetime.now()
        # FIXME self.statistics.iteration_time.put(this_time - self.statistics.last_time.value)
        # FIXME self.statistics.last_time[:] = str(this_time)
        return box

    def _get_box_to_plot(self):
        return self.boxes_to_plot.get(timeout=self.config.queue_timeout)

    def _extract_point(self, model):
        point = Point(
            values={
                # p.name: float(model.assignment[p.symbol()].constant_value())
                p.name: float(model.get_py_value(p.symbol()))
                for p in self.problem.parameters
            }
        )
        return point


class BoxSearchEpisodeMP(BoxSearchEpisode):
    class Config:
        underscore_attrs_are_private = True

    statistics: SearchStaticsMP = None
    _unknown_boxes: Queue
    _iteration: Value = None

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        manager = kwargs["manager"]
        self._unknown_boxes = manager.Queue()
        self._iteration = manager.Value("i", 0)
        self.statistics = SearchStaticsMP(manager=kwargs["manager"])
